---
sidebar_position: 0
---
import FeatureWidget from '@site/src/components/domain/widgets/feature.js'

# What is a feature?

***An object oriented programming perspective*** <br />
In many object oriented programming language a feature describes what an unknown type of object can do. The same way a CliNext feature describes what an unknown database object can do. 

A feature always applies to a class, which is the CliNext representation of a database table.

By applying a feature to a class we make it conform to the the feature's schema, meaning the class' schema will be updated to include the extra fields the feature needs to work. Even more, the feature listens to all the events (triggers) sent to the class (beforeSave, afterSave, beforeDelete, afterDelete, ...) so that the class' behavior conforms to the feature's behavior. The feature does not cancel the class' own desired behavior, it gets executed in a chain alongside all the class' features triggers.

A class can have multiple features.
Every class can customize the way it uses a feature to an extent (feature parameters).
The same way a feature can be applied to multiple models.

A feature has no knowledge of the class it's being applied to. It simply manipulates it according to the declared fields and parameters.


## A better way to group repeatable logic on a database object
Let's say you have an e-commerce application that enables user comments on a blog page and on a product page. You would probably create a table in your database that holds the comments, with a foreign key to the user who made the comment. For performance reasons you would keep the comments count on the object that is being commented, alongside a reference to a "relevant" comment. You would add those fields to both the blog page table and the product page. Every change you would make the comments system design would have to be manually updated to those two tables.

We can do much better by creating a feature called *commentable* that will be responsible for:

- Defining the schema and creating the tables needed for the comment feature, ie CommentableEntry
- Adding the proper fields to every object that is *commentable*, we call them projected field, in this case they are named CommentableRelevantEntry, CommentableCount
- The security and ACL for the CommentableEntry table and the fields 
- For defining object level logic to its own object models
- For reacting to object events, for example beforeSave, afterSave, beforeDelete, afterDelete and make sure the object is at all time coherent with the feature rules

By doing so we have packaged the ability to comment into one component that can be reused easily across the project.

A feature does not stop at the server. Some features have a client counterpart that acts in tandem with the server. If we consider the Commentable feature, it can be distributed in a commentable-server npm package, alongside a commentable-react package that contains React components that can be called on any object that conforms to the feature. The components include, for a commentable object:
- **CommentableList** that displays a paginated list of comments 
- **CommentableComment** that displays a paginated list of comments
- **CommentableCommentsCount** that displays the total number of comments 
- **CommentableCommentsExcerpt** that displays an excerpt

By making an object Commentable, you're adding not only database fields and server methods to it, you are also taking advantage of a front library made for its capacity.


<div className=''>
<FeatureWidget id={'@clinext-community/framable'} />
</div>
<div className='mt-10'>
    <FeatureWidget id={'publish@clinext-community/framableable'} size={'m'} />
</div>
{/* 
## Lifecycle
```mermaid
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'primaryColor': '#fff',
      'primaryTextColor': '#323232',
      'primaryBorderColor': '#323232',
      'lineColor': '#323232',
      'fontFamily': 'Space Grotesk'       
    }
  }
}%%
stateDiagram
    [*] --> beforeInit
    beforeInit --> seed
    seed --> afterInit
    afterInit --> [*]
``` */}
